"""Render `examples/README.md` from the manifest metadata.

This utility converts the structured entries in ``examples/examples_manifest.yaml``
into a Markdown index that introduces the available example tiers, documents
prerequisites, and highlights CI coverage status. The resulting README is the
human-facing companion to the manifest and should be regenerated after any
metadata change.

Example:
    uv run python scripts/validation/render_examples_readme.py

"""

from __future__ import annotations

import argparse
import sys
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

from robot_sf.examples import ExampleManifest, ExampleScript, ManifestValidationError, load_manifest

HEADER = """# Robot SF Examples Index

> _This file is auto-generated by `scripts/validation/render_examples_readme.py`._
> _Edit the manifest or supporting scripts instead of modifying this README directly._

The examples are organized into learning tiers. Start with **Quickstart** for
an introductory walkthrough, explore **Advanced Features** for targeted demos,
runtime evaluation tooling lives under **Benchmarks**, and plotting resources
reside in **Plotting & Analysis**. Archived scripts remain available for
reference but are excluded from CI by default.

"""

DECISION_TREE_NOTE = """## Quickstart Decision Path

1. **New to Robot SF?** Begin with the quickstart tier to learn environment
   creation and trained-agent playback. These examples run headless and require
   no additional assets.
2. **Exploring specific features?** Jump to the advanced section and filter by
   tags such as `image`, `pedestrian`, or `backend`.
3. **Validating performance?** Use the benchmark runners to generate JSONL
   outputs for aggregation tooling.
4. **Visualizing results?** Plotting scripts transform benchmark outputs into
   figures for documentation and analysis.

"""


def parse_args() -> argparse.Namespace:
    """Parse command line arguments."""

    parser = argparse.ArgumentParser(
        description="Render the examples README using the manifest metadata."
    )
    parser.add_argument(
        "--manifest",
        type=Path,
        default=None,
        help="Path to the manifest file (defaults to examples/examples_manifest.yaml).",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=None,
        help="Destination for the generated README (defaults to examples/README.md).",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print the generated markdown to stdout instead of writing to disk.",
    )
    parser.add_argument(
        "--include-archived",
        action="store_true",
        help="Include the _Archived section alongside active categories.",
    )
    parser.add_argument(
        "--skip-ci-column",
        action="store_true",
        help="Omit the CI status column from generated tables.",
    )
    parser.add_argument(
        "--validate-paths",
        action="store_true",
        help="Ensure manifest entries exist on disk before rendering.",
    )
    return parser.parse_args()


def main() -> int:
    """Program entry point."""

    args = parse_args()

    try:
        manifest = load_manifest(args.manifest, validate_paths=args.validate_paths)
    except ManifestValidationError as exc:
        print(f"ERROR: {exc}", file=sys.stderr)
        return 1

    output_path = args.output if args.output is not None else (manifest.examples_root / "README.md")

    markdown = build_markdown(
        manifest,
        include_archived=args.include_archived,
        include_ci_column=not args.skip_ci_column,
    )

    if args.dry_run:
        print(markdown)
        return 0

    output_path.write_text(markdown, encoding="utf-8")
    print(f"Wrote README to {output_path.as_posix()}")
    return 0


def build_markdown(
    manifest: ExampleManifest,
    *,
    include_archived: bool,
    include_ci_column: bool,
) -> str:
    """Construct the README body from manifest data."""

    sections: list[str] = [HEADER, DECISION_TREE_NOTE]

    for category in manifest.categories:
        if not include_archived and category.slug == "_archived":
            continue
        sections.append(
            render_category_section(
                manifest,
                category.slug,
                include_ci_column=include_ci_column,
            )
        )

    if include_archived:
        archived_section = render_archived_guidance(manifest)
        if archived_section:
            sections.append(archived_section)

    return "\n".join(section.rstrip() for section in sections if section)


def build_table_header(*, include_ci_column: bool) -> str:
    """Create a Markdown table header with optional CI column."""

    columns = ["Example", "Summary", "Prerequisites", "Tags"]
    if include_ci_column:
        columns.append("CI")

    header = "| " + " | ".join(columns) + " |"
    separator = "| " + " | ".join("---" for _ in columns) + " |"
    return f"{header}\n{separator}"


def render_category_section(
    manifest: ExampleManifest,
    category_slug: str,
    *,
    include_ci_column: bool,
) -> str:
    """Render a single category section as Markdown."""

    category = manifest.categories_by_slug[category_slug]
    examples = sorted(
        manifest.examples_for_category(category_slug),
        key=lambda example: example.path.as_posix(),
    )

    lines: list[str] = [f"## {category.title}", "", category.description, ""]

    if not examples:
        lines.append("_No examples assigned yet._")
        lines.append("")
        return "\n".join(lines)

    header = build_table_header(include_ci_column=include_ci_column)
    lines.append(header)

    for example in examples:
        entry = render_table_row(example, include_ci_column=include_ci_column)
        lines.append(entry)

    lines.append("")
    return "\n".join(lines)


def render_table_row(example: ExampleScript, *, include_ci_column: bool) -> str:
    """Return the Markdown table row for a single example."""

    link = f"[{example.name}](./{example.path.as_posix()})"
    prerequisites = format_prerequisites(example.prerequisites)
    tags = ", ".join(example.tags) if example.tags else "_None_"

    if include_ci_column:
        ci_status = "✅" if example.ci_enabled else f"⚠️ {example.ci_reason or 'Disabled'}"
        return f"| {link} | {example.summary} | {prerequisites} | {tags} | {ci_status} |"
    return f"| {link} | {example.summary} | {prerequisites} | {tags} |"


def format_prerequisites(prerequisites: Iterable[str]) -> str:
    """Format prerequisites for table display."""

    items = list(prerequisites)
    if not items:
        return "_None_"
    return "<br>".join(items)


def render_archived_guidance(manifest: ExampleManifest) -> str:
    """Summarize archived examples with their CI rationale."""

    archived = manifest.examples_for_category("_archived")
    if not archived:
        return ""

    lines = [
        "## Archived",
        "",
        "Examples in this section are deprecated, interactive-only, or otherwise excluded from CI.",
        "",
        build_table_header(include_ci_column=True),
    ]

    for example in sorted(archived, key=lambda item: item.path.as_posix()):
        ci_reason = example.ci_reason or "Disabled"
        lines.append(
            f"| [{example.name}](./{example.path.as_posix()}) | {example.summary} | "
            f"{format_prerequisites(example.prerequisites)} | {', '.join(example.tags) or '_None_'} | ⚠️ {ci_reason} |"
        )

    lines.append("")
    return "\n".join(lines)


if __name__ == "__main__":  # pragma: no cover - CLI entry point
    sys.exit(main())
