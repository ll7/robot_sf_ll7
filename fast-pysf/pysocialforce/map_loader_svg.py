"""extract the information of the path in the svg file generated by InkScape"""
import xml.etree.ElementTree as ET
import re
import logging
import numpy as np

from pysocialforce.map_config import MapDefinition, Obstacle, GlobalRoute, Zone

logger = logging.getLogger(__name__)


def svg_path_info(svg_file):
    """
    Extracts path information from an SVG file.

    returns a list of dictionaries, each containing the following keys:
    - 'coordinates': a numpy array of shape (n, 2) containing the x and y coordinates
    - 'label': the 'inkscape:label' attribute of the path
    - 'id': the 'id' attribute of the path
    """
    logger.info("Extracting path information from: %s", svg_file)

    # Parse the SVG file
    svg_tree = ET.parse(svg_file)
    svg_root = svg_tree.getroot()

    # Define the SVG and Inkscape namespaces
    namespaces = {
        'svg': 'http://www.w3.org/2000/svg',
        'inkscape': 'http://www.inkscape.org/namespaces/inkscape'
        }

    # Find all 'path' elements in the SVG file
    paths = svg_root.findall('.//svg:path', namespaces)

    # Initialize an empty list to store the path information
    path_info = []

    # Compile the regex pattern for performance
    coordinate_pattern = re.compile(r"([+-]?[0-9]*\.?[0-9]+)[, ]([+-]?[0-9]*\.?[0-9]+)")

    # Iterate over each 'path' element
    for path in paths:
        # Extract the 'd' attribute (coordinates), 'inkscape:label' and 'id'
        input_string = path.attrib.get('d')
        if not input_string:
            continue  # Skip paths without the 'd' attribute

        label = path.attrib.get('{http://www.inkscape.org/namespaces/inkscape}label')
        id_ = path.attrib.get('id')

        # Find all matching coordinates
        filtered_coordinates = coordinate_pattern.findall(input_string)
        if not filtered_coordinates:
            logger.warning("No coordinates found for path: %s", id_)
            continue

        # Convert the matched strings directly into a numpy array of floats
        np_coordinates = np.array(filtered_coordinates, dtype=float)

        # Append the information to the list
        path_info.append({'coordinates': np_coordinates, 'label': label, 'id': id_})

    return path_info


def path_info_to_mapdefintion(path_info):
    """
    Convert the path information to a MapDefinition object.

    Args:
        path_info (List[Dict]): A list of dictionaries containing path information.

    Returns:
        MapDefinition: A MapDefinition object containing the map components.
    """
    obstacles = []
    routes = []
    crowded_zones = []
    for path in path_info:

        # check the label of the path
        if path['label'] == 'obstacle':
            # Convert the coordinates to a list of vertices
            vertices = path['coordinates'].tolist()

            # Check if the first and last verices are the same
            if not np.array_equal(vertices[0], vertices[-1]):
                logger.warning(
                    "The first and last vertices of the obstacle in path <%s> are not the same. " +
                    "Adding the first vertex to the end to close the polygon.",
                    path['id']
                    )
                # Add the first vertex to the end to close the polygon
                vertices.append(vertices[0])
                # TODO is it really necessary to close the polygon?

            # Append the obstacle to the list
            obstacles.append(Obstacle(vertices))

        elif path['label'] == 'route':
            # Convert the coordinates to a list of vertices
            vertices = path['coordinates'].tolist()

            # Append the obstacle to the list
            routes.append(GlobalRoute(vertices))

        elif path['label'] == 'crowded_zone':
            # Convert the coordinates to a list of vertices
            vertices = path['coordinates'].tolist()

            # Append the crowded zone to the list
            crowded_zones.append(Zone(vertices))

        else:
            logger.warning(
                "Unknown label <%s> in id <%s>",
                path['label'],
                path['id']
                )

    # check if the lists are empty and raise a warning
    if not obstacles:
        logger.warning("No obstacles found in the SVG file")
    if not routes:
        logger.warning("No routes found in the SVG file")
    if not crowded_zones:
        logger.warning("No crowded zones found in the SVG file")

    return MapDefinition(obstacles, routes, crowded_zones)
