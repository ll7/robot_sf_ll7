# Feature Specification: Ruff Docstring Enforcement

**Feature Branch**: `001-ruff-docstrings`  
**Created**: 2025-12-02  
**Status**: Draft  
**Input**: User description: "I, as a user, want to add the requirement to the project to add docstrings to all methods. To ensure this, I want to enable ruff rules. I want to enable many of the pydocstyle rules (D) and pydoclint rules (DOC). I want to enable these rules, and then I want to fix all new ruff doc errors. Everything should be well documented. Rules I want to enable: D100-D107, D417, D419, D102, D201"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Maintainer enforces docstrings at commit time (Priority: P1)

Repository maintainers need Ruff to block merges whenever a public module, class, function, or method is missing a compliant docstring, so that code quality does not rely on manual review alone.

**Why this priority**: Automated enforcement is the fastest way to achieve universal documentation coverage and removes subjective debates during review.

**Independent Test**: Run `uv run ruff check` on a branch where a new method lacks a docstring; verify the command fails with a D1xx/D4xx error before any other feature is touched.

**Acceptance Scenarios**:

1. **Given** a developer adds a new public method without a docstring, **When** Ruff runs locally or in CI, **Then** the run fails with the precise docstring rule explaining what is missing.
2. **Given** a developer adds a docstring that omits a `Returns` section for a non-`None` return value, **When** Ruff runs, **Then** rule D419 reports the omission until the description is added.

---

### User Story 2 - Contributor fixes legacy files efficiently (Priority: P2)

Contributors need actionable lint output that groups docstring issues per file so they can remediate legacy modules without guesswork.

**Why this priority**: The project already contains many modules; remediation must be efficient to avoid slowing down other roadmap work.

**Independent Test**: Introduce missing or low-quality docstrings in a legacy module, run Ruff with docstring rules enabled, and verify the output highlights file, rule, and quick guidance so the contributor can address issues without additional tooling.

**Acceptance Scenarios**:

1. **Given** a module containing classes without class-level docstrings, **When** Ruff runs, **Then** each class is flagged with D101 plus an actionable message referencing that class.
2. **Given** a function whose docstring fails to describe parameters, **When** Ruff runs, **Then** rule D417 identifies every undocumented parameter so the contributor can fix them in one pass.

---

### User Story 3 - Documentation consumers trust generated references (Priority: P3)

Docs writers or downstream users reading generated API docs need every public API to include accurate summaries, parameter explanations, and return semantics so that the generated documentation can be published without manual patch-ups.

**Why this priority**: High-quality docstrings enable reliable auto-generated documentation and reduce post-generation editing.

**Independent Test**: Generate API docs (e.g., via Sphinx or pdoc) after lint clean-up and confirm that each exported symbol contains the information enforced by Ruff rules.

**Acceptance Scenarios**:

1. **Given** an exported class with `__init__`, **When** documentation is generated, **Then** both the class and initializer docstrings describe purpose and parameters, reflecting D101/D105 coverage.
2. **Given** a public function returning complex data, **When** documentation is generated, **Then** the docstring describes the return contract per D419 so readers understand usage without inspecting code.

---

### Edge Cases

- How are autogenerated or protocol-mandated methods (e.g., `__repr__`, dataclass helpers) documented without introducing noise while still satisfying D105/D107?
- How do we document very small helper functions in tests or internal modules without overwhelming contributors, and do we exempt explicitly private helpers (leading underscore) while keeping public APIs strict?
- What happens when third-party vendored code lacks docstrings—do we exclude those directories from Ruff or inject minimal docstrings during vendoring?

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: The lint configuration MUST enable Ruff docstring rules D100–D107, D417, D419, D102, and D201 for the `robot_sf` project and any other user-facing Python packages in the repo.
- **FR-002**: CI and local developer workflows MUST treat docstring rule violations as failures so code cannot merge without compliant documentation.
- **FR-003**: Every public module, class, method, and function MUST provide a docstring summarizing its purpose, inputs, outputs, and side effects at a level consistent with D1xx/D4xx requirements.
- **FR-004**: Docstrings for callables with parameters MUST enumerate and describe each parameter (including `self`-less helpers) to satisfy D417 coverage expectations.
- **FR-005**: Docstrings for callables with return values MUST explicitly describe the returned data per D419, indicating units, types, or meaning.
- **FR-006**: Special methods (`__init__`, `__call__`, context managers) MUST include docstrings that explain their role and contract so D105/D107 pass without suppressions.
- **FR-007**: The remediation effort MUST clean all existing code so that running Ruff with the new rule set produces zero docstring violations on `main` after the feature merges.

### Key Entities

- **Docstring Rule Set**: The collection of Ruff-enabled docstring checks (D100–D107, D417, D419, D102, D201) that define the minimum documentation contract for every public API element.
- **Documentation Artifact**: Generated API references and inline help sourced from docstrings, consumed by maintainers, QA, and users for understanding behaviors without diving into code.

### Assumptions

- Private helpers (prefixed with `_`) and auto-generated code under `fast-pysf/` may remain excluded from strict enforcement unless they form part of the user-facing API surface.
- Contributors already run Ruff locally; enabling additional rules primarily expands coverage rather than introducing a new tool.
- CI capacity is sufficient to run the expanded lint suite without exceeding existing time budgets.

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: `uv run ruff check` (and the corresponding CI task) completes with zero docstring rule failures on the default branch immediately after the feature merges.
- **SC-002**: 100% of public modules, classes, functions, and methods in `robot_sf` and associated tooling contain docstrings that meet the enforced rule set, verified by Ruff lint reports and spot documentation review.
- **SC-003**: New pull requests that introduce public APIs and lack compliant docstrings are automatically blocked by CI within one minute of lint execution, ensuring regressions are caught before review.
- **SC-004**: Generated API documentation (smoke-tested on a representative subset) no longer contains placeholder or missing sections for parameters/returns, demonstrating that docstrings provide sufficient structured information for downstream tooling.
